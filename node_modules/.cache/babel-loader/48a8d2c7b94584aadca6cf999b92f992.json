{"ast":null,"code":"/*!\r\n * https://github.com/Starcounter-Jack/JSON-Patch\r\n * (c) 2017 Joachim Wester\r\n * MIT license\r\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function hasOwnProperty(obj, key) {\n  return _hasOwnProperty.call(obj, key);\n}\nexport function _objectKeys(obj) {\n  if (Array.isArray(obj)) {\n    var keys = new Array(obj.length);\n\n    for (var k = 0; k < keys.length; k++) {\n      keys[k] = \"\" + k;\n    }\n\n    return keys;\n  }\n\n  if (Object.keys) {\n    return Object.keys(obj);\n  }\n\n  var keys = [];\n\n  for (var i in obj) {\n    if (hasOwnProperty(obj, i)) {\n      keys.push(i);\n    }\n  }\n\n  return keys;\n}\n;\n/**\r\n* Deeply clone the object.\r\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\r\n* @param  {any} obj value to clone\r\n* @return {any} cloned obj\r\n*/\n\nexport function _deepClone(obj) {\n  switch (typeof obj) {\n    case \"object\":\n      return JSON.parse(JSON.stringify(obj));\n    //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n\n    case \"undefined\":\n      return null;\n    //this is how JSON.stringify behaves for array items\n\n    default:\n      return obj;\n    //no need to clone primitives\n  }\n} //3x faster than cached /^\\d+$/.test(str)\n\nexport function isInteger(str) {\n  var i = 0;\n  var len = str.length;\n  var charCode;\n\n  while (i < len) {\n    charCode = str.charCodeAt(i);\n\n    if (charCode >= 48 && charCode <= 57) {\n      i++;\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n/**\r\n* Escapes a json pointer path\r\n* @param path The raw pointer\r\n* @return the Escaped path\r\n*/\n\nexport function escapePathComponent(path) {\n  if (path.indexOf('/') === -1 && path.indexOf('~') === -1) return path;\n  return path.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\r\n * Unescapes a json pointer path\r\n * @param path The escaped pointer\r\n * @return The unescaped path\r\n */\n\nexport function unescapePathComponent(path) {\n  return path.replace(/~1/g, '/').replace(/~0/g, '~');\n}\nexport function _getPathRecursive(root, obj) {\n  var found;\n\n  for (var key in root) {\n    if (hasOwnProperty(root, key)) {\n      if (root[key] === obj) {\n        return escapePathComponent(key) + '/';\n      } else if (typeof root[key] === 'object') {\n        found = _getPathRecursive(root[key], obj);\n\n        if (found != '') {\n          return escapePathComponent(key) + '/' + found;\n        }\n      }\n    }\n  }\n\n  return '';\n}\nexport function getPath(root, obj) {\n  if (root === obj) {\n    return '/';\n  }\n\n  var path = _getPathRecursive(root, obj);\n\n  if (path === '') {\n    throw new Error(\"Object not found in root\");\n  }\n\n  return '/' + path;\n}\n/**\r\n* Recursively checks whether an object has any undefined values inside.\r\n*/\n\nexport function hasUndefined(obj) {\n  if (obj === undefined) {\n    return true;\n  }\n\n  if (obj) {\n    if (Array.isArray(obj)) {\n      for (var i = 0, len = obj.length; i < len; i++) {\n        if (hasUndefined(obj[i])) {\n          return true;\n        }\n      }\n    } else if (typeof obj === \"object\") {\n      var objKeys = _objectKeys(obj);\n\n      var objKeysLength = objKeys.length;\n\n      for (var i = 0; i < objKeysLength; i++) {\n        if (hasUndefined(obj[objKeys[i]])) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction patchErrorMessageFormatter(message, args) {\n  var messageParts = [message];\n\n  for (var key in args) {\n    var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print\n\n    if (typeof value !== 'undefined') {\n      messageParts.push(key + \": \" + value);\n    }\n  }\n\n  return messageParts.join('\\n');\n}\n\nvar PatchError =\n/** @class */\nfunction (_super) {\n  __extends(PatchError, _super);\n\n  function PatchError(message, name, index, operation, tree) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, patchErrorMessageFormatter(message, {\n      name: name,\n      index: index,\n      operation: operation,\n      tree: tree\n    })) || this;\n\n    _this.name = name;\n    _this.index = index;\n    _this.operation = operation;\n    _this.tree = tree;\n    Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n\n    _this.message = patchErrorMessageFormatter(message, {\n      name: name,\n      index: index,\n      operation: operation,\n      tree: tree\n    });\n    return _this;\n  }\n\n  return PatchError;\n}(Error);\n\nexport { PatchError };","map":null,"metadata":{},"sourceType":"module"}