{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr, domainNameCharRegex } from \"../regex-lib\";\nimport { EmailMatch } from \"../match/email-match\";\nimport { throwUnhandledCaseError } from '../utils';\nimport { tldRegex } from \"./tld-regex\"; // For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n// RegExp objects which are shared by all instances of EmailMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating EmailMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\n\nvar localPartCharRegex = new RegExp(\"[\" + alphaNumericAndMarksCharsStr + \"!#$%&'*+/=?^_`{|}~-]\");\nvar strictTldRegex = new RegExp(\"^\" + tldRegex.source + \"$\");\n/**\n * @class Autolinker.matcher.Email\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find email matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n */\n\nvar EmailMatcher =\n/** @class */\nfunction (_super) {\n  __extends(EmailMatcher, _super);\n\n  function EmailMatcher() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * Valid characters that can be used in the \"local\" part of an email address,\n     * i.e. the \"name\" part of \"name@site.com\"\n     */\n\n\n    _this.localPartCharRegex = localPartCharRegex;\n    /**\n     * Stricter TLD regex which adds a beginning and end check to ensure\n     * the string is a valid TLD\n     */\n\n    _this.strictTldRegex = strictTldRegex;\n    return _this;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  EmailMatcher.prototype.parseMatches = function (text) {\n    var tagBuilder = this.tagBuilder,\n        localPartCharRegex = this.localPartCharRegex,\n        strictTldRegex = this.strictTldRegex,\n        matches = [],\n        len = text.length,\n        noCurrentEmailMatch = new CurrentEmailMatch(); // for matching a 'mailto:' prefix\n\n    var mailtoTransitions = {\n      'm': 'a',\n      'a': 'i',\n      'i': 'l',\n      'l': 't',\n      't': 'o',\n      'o': ':'\n    };\n    var charIdx = 0,\n        state = 0\n    /* NonEmailMatch */\n    ,\n        currentEmailMatch = noCurrentEmailMatch; // For debugging: search for other \"For debugging\" lines\n    // const table = new CliTable( {\n    // \thead: [ 'charIdx', 'char', 'state', 'charIdx', 'currentEmailAddress.idx', 'hasDomainDot' ]\n    // } );\n\n    while (charIdx < len) {\n      var char = text.charAt(charIdx); // For debugging: search for other \"For debugging\" lines\n      // table.push( \n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n      // );\n\n      switch (state) {\n        case 0\n        /* NonEmailMatch */\n        :\n          stateNonEmailAddress(char);\n          break;\n\n        case 1\n        /* Mailto */\n        :\n          stateMailTo(text.charAt(charIdx - 1), char);\n          break;\n\n        case 2\n        /* LocalPart */\n        :\n          stateLocalPart(char);\n          break;\n\n        case 3\n        /* LocalPartDot */\n        :\n          stateLocalPartDot(char);\n          break;\n\n        case 4\n        /* AtSign */\n        :\n          stateAtSign(char);\n          break;\n\n        case 5\n        /* DomainChar */\n        :\n          stateDomainChar(char);\n          break;\n\n        case 6\n        /* DomainHyphen */\n        :\n          stateDomainHyphen(char);\n          break;\n\n        case 7\n        /* DomainDot */\n        :\n          stateDomainDot(char);\n          break;\n\n        default:\n          throwUnhandledCaseError(state);\n      } // For debugging: search for other \"For debugging\" lines\n      // table.push( \n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n      // );\n\n\n      charIdx++;\n    } // Capture any valid match at the end of the string\n\n\n    captureMatchIfValidAndReset(); // For debugging: search for other \"For debugging\" lines\n    //console.log( '\\n' + table.toString() );\n\n    return matches; // Handles the state when we're not in an email address\n\n    function stateNonEmailAddress(char) {\n      if (char === 'm') {\n        beginEmailMatch(1\n        /* Mailto */\n        );\n      } else if (localPartCharRegex.test(char)) {\n        beginEmailMatch();\n      } else {// not an email address character, continue\n      }\n    } // Handles if we're reading a 'mailto:' prefix on the string\n\n\n    function stateMailTo(prevChar, char) {\n      if (prevChar === ':') {\n        // We've reached the end of the 'mailto:' prefix\n        if (localPartCharRegex.test(char)) {\n          state = 2\n          /* LocalPart */\n          ;\n          currentEmailMatch = new CurrentEmailMatch(__assign(__assign({}, currentEmailMatch), {\n            hasMailtoPrefix: true\n          }));\n        } else {\n          // we've matched 'mailto:' but didn't get anything meaningful\n          // immediately afterwards (for example, we encountered a \n          // space character, or an '@' character which formed 'mailto:@'\n          resetToNonEmailMatchState();\n        }\n      } else if (mailtoTransitions[prevChar] === char) {// We're currently reading the 'mailto:' prefix, stay in\n        // Mailto state\n      } else if (localPartCharRegex.test(char)) {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // different character that didn't continue the prefix\n        state = 2\n        /* LocalPart */\n        ;\n      } else if (char === '.') {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // dot character\n        state = 3\n        /* LocalPartDot */\n        ;\n      } else if (char === '@') {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // an @ character\n        state = 4\n        /* AtSign */\n        ;\n      } else {\n        // not an email address character, return to \"NonEmailAddress\" state\n        resetToNonEmailMatchState();\n      }\n    } // Handles the state when we're currently in the \"local part\" of an \n    // email address (as opposed to the \"domain part\")\n\n\n    function stateLocalPart(char) {\n      if (char === '.') {\n        state = 3\n        /* LocalPartDot */\n        ;\n      } else if (char === '@') {\n        state = 4\n        /* AtSign */\n        ;\n      } else if (localPartCharRegex.test(char)) {// stay in the \"local part\" of the email address\n      } else {\n        // not an email address character, return to \"NonEmailAddress\" state\n        resetToNonEmailMatchState();\n      }\n    } // Handles the state where we've read \n\n\n    function stateLocalPartDot(char) {\n      if (char === '.') {\n        // We read a second '.' in a row, not a valid email address \n        // local part\n        resetToNonEmailMatchState();\n      } else if (char === '@') {\n        // We read the '@' character immediately after a dot ('.'), not \n        // an email address\n        resetToNonEmailMatchState();\n      } else if (localPartCharRegex.test(char)) {\n        state = 2\n        /* LocalPart */\n        ;\n      } else {\n        // Anything else, not an email address\n        resetToNonEmailMatchState();\n      }\n    }\n\n    function stateAtSign(char) {\n      if (domainNameCharRegex.test(char)) {\n        state = 5\n        /* DomainChar */\n        ;\n      } else {\n        // Anything else, not an email address\n        resetToNonEmailMatchState();\n      }\n    }\n\n    function stateDomainChar(char) {\n      if (char === '.') {\n        state = 7\n        /* DomainDot */\n        ;\n      } else if (char === '-') {\n        state = 6\n        /* DomainHyphen */\n        ;\n      } else if (domainNameCharRegex.test(char)) {// Stay in the DomainChar state\n      } else {\n        // Anything else, we potentially matched if the criteria has\n        // been met\n        captureMatchIfValidAndReset();\n      }\n    }\n\n    function stateDomainHyphen(char) {\n      if (char === '-' || char === '.') {\n        // Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n        captureMatchIfValidAndReset();\n      } else if (domainNameCharRegex.test(char)) {\n        state = 5\n        /* DomainChar */\n        ;\n      } else {\n        // Anything else\n        captureMatchIfValidAndReset();\n      }\n    }\n\n    function stateDomainDot(char) {\n      if (char === '.' || char === '-') {\n        // not valid to have two dots (\"..\") or dot+hypen (\".-\")\n        captureMatchIfValidAndReset();\n      } else if (domainNameCharRegex.test(char)) {\n        state = 5\n        /* DomainChar */\n        ; // After having read a '.' and then a valid domain character,\n        // we now know that the domain part of the email is valid, and\n        // we have found at least a partial EmailMatch (however, the\n        // email address may have additional characters from this point)\n\n        currentEmailMatch = new CurrentEmailMatch(__assign(__assign({}, currentEmailMatch), {\n          hasDomainDot: true\n        }));\n      } else {\n        // Anything else\n        captureMatchIfValidAndReset();\n      }\n    }\n\n    function beginEmailMatch(newState) {\n      if (newState === void 0) {\n        newState = 2\n        /* LocalPart */\n        ;\n      }\n\n      state = newState;\n      currentEmailMatch = new CurrentEmailMatch({\n        idx: charIdx\n      });\n    }\n\n    function resetToNonEmailMatchState() {\n      state = 0\n      /* NonEmailMatch */\n      ;\n      currentEmailMatch = noCurrentEmailMatch;\n    }\n    /*\n     * Captures the current email address as an EmailMatch if it's valid,\n     * and resets the state to read another email address.\n     */\n\n\n    function captureMatchIfValidAndReset() {\n      if (currentEmailMatch.hasDomainDot) {\n        // we need at least one dot in the domain to be considered a valid email address\n        var matchedText = text.slice(currentEmailMatch.idx, charIdx); // If we read a '.' or '-' char that ended the email address\n        // (valid domain name characters, but only valid email address\n        // characters if they are followed by something else), strip \n        // it off now\n\n        if (/[-.]$/.test(matchedText)) {\n          matchedText = matchedText.slice(0, -1);\n        }\n\n        var emailAddress = currentEmailMatch.hasMailtoPrefix ? matchedText.slice('mailto:'.length) : matchedText; // if the email address has a valid TLD, add it to the list of matches\n\n        if (doesEmailHaveValidTld(emailAddress)) {\n          matches.push(new EmailMatch({\n            tagBuilder: tagBuilder,\n            matchedText: matchedText,\n            offset: currentEmailMatch.idx,\n            email: emailAddress\n          }));\n        }\n      }\n\n      resetToNonEmailMatchState();\n      /**\n       * Determines if the given email address has a valid TLD or not\n       * @param {string} emailAddress - email address\n       * @return {Boolean} - true is email have valid TLD, false otherwise\n       */\n\n      function doesEmailHaveValidTld(emailAddress) {\n        var emailAddressTld = emailAddress.split('.').pop() || '';\n        var emailAddressNormalized = emailAddressTld.toLowerCase();\n        var isValidTld = strictTldRegex.test(emailAddressNormalized);\n        return isValidTld;\n      }\n    }\n  };\n\n  return EmailMatcher;\n}(Matcher);\n\nexport { EmailMatcher };\n\nvar CurrentEmailMatch =\n/** @class */\nfunction () {\n  function CurrentEmailMatch(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.idx = cfg.idx !== undefined ? cfg.idx : -1;\n    this.hasMailtoPrefix = !!cfg.hasMailtoPrefix;\n    this.hasDomainDot = !!cfg.hasDomainDot;\n  }\n\n  return CurrentEmailMatch;\n}();","map":{"version":3,"sources":["../src/matcher/email-matcher.ts"],"names":[],"mappings":"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","sourcesContent":["import { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr, domainNameCharRegex } from \"../regex-lib\";\nimport { EmailMatch } from \"../match/email-match\";\nimport { Match } from \"../match/match\";\nimport { throwUnhandledCaseError } from '../utils';\nimport { tldRegex } from \"./tld-regex\";\n\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\n// RegExp objects which are shared by all instances of EmailMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating EmailMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\nconst localPartCharRegex = new RegExp( `[${alphaNumericAndMarksCharsStr}!#$%&'*+/=?^_\\`{|}~-]` );\nconst strictTldRegex = new RegExp( `^${tldRegex.source}$` );\n\n/**\n * @class Autolinker.matcher.Email\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find email matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n */\nexport class EmailMatcher extends Matcher {\n\n\t/**\n\t * Valid characters that can be used in the \"local\" part of an email address,\n\t * i.e. the \"name\" part of \"name@site.com\"\n\t */\n\tprotected localPartCharRegex = localPartCharRegex;\n\n\t/**\n\t * Stricter TLD regex which adds a beginning and end check to ensure\n\t * the string is a valid TLD\n\t */\n\tprotected strictTldRegex = strictTldRegex;\n\n\n\t/**\n\t * @inheritdoc\n\t */\n\tparseMatches( text: string ) {\n\t\tconst tagBuilder = this.tagBuilder,\n\t\t\t  localPartCharRegex = this.localPartCharRegex,\n\t\t\t  strictTldRegex = this.strictTldRegex,\n\t\t\t  matches: Match[] = [],\n\t\t\t  len = text.length,\n\t\t\t  noCurrentEmailMatch = new CurrentEmailMatch();\n\n\t\t// for matching a 'mailto:' prefix\n\t\tconst mailtoTransitions = {\n\t\t\t'm': 'a',\n\t\t\t'a': 'i',\n\t\t\t'i': 'l',\n\t\t\t'l': 't',\n\t\t\t't': 'o',\n\t\t\t'o': ':',\n\t\t};\n\n\t\tlet charIdx = 0,\n\t\t\tstate = State.NonEmailMatch as State,\n\t\t\tcurrentEmailMatch = noCurrentEmailMatch;\n\n\t\t// For debugging: search for other \"For debugging\" lines\n\t\t// const table = new CliTable( {\n\t\t// \thead: [ 'charIdx', 'char', 'state', 'charIdx', 'currentEmailAddress.idx', 'hasDomainDot' ]\n\t\t// } );\n\n\t\twhile( charIdx < len ) {\n\t\t\tconst char = text.charAt( charIdx );\n\n\t\t\t// For debugging: search for other \"For debugging\" lines\n\t\t\t// table.push( \n\t\t\t// \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n\t\t\t// );\n\n\t\t\tswitch( state ) {\n\t\t\t\tcase State.NonEmailMatch: stateNonEmailAddress( char ); break;\n\n\t\t\t\tcase State.Mailto: \n\t\t\t\t\tstateMailTo( text.charAt( charIdx - 1 ) as MailtoChar, char ); \n\t\t\t\t\tbreak;\n\t\t\t\tcase State.LocalPart: stateLocalPart( char ); break;\n\t\t\t\tcase State.LocalPartDot: stateLocalPartDot( char ); break;\n\t\t\t\tcase State.AtSign: stateAtSign( char ); break;\n\t\t\t\tcase State.DomainChar: stateDomainChar( char ); break;\n\t\t\t\tcase State.DomainHyphen: stateDomainHyphen( char ); break;\n\t\t\t\tcase State.DomainDot: stateDomainDot( char ); break;\n\t\n\t\t\t\tdefault: \n\t\t\t\t\tthrowUnhandledCaseError( state );\n\t\t\t}\n\n\t\t\t// For debugging: search for other \"For debugging\" lines\n\t\t\t// table.push( \n\t\t\t// \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n\t\t\t// );\n\n\t\t\tcharIdx++;\n\t\t}\n\n\t\t// Capture any valid match at the end of the string\n\t\tcaptureMatchIfValidAndReset();\n\n\t\t// For debugging: search for other \"For debugging\" lines\n\t\t//console.log( '\\n' + table.toString() );\n\t\t\n\t\treturn matches;\n\n\n\t\t// Handles the state when we're not in an email address\n\t\tfunction stateNonEmailAddress( char: string ) {\n\t\t\tif( char === 'm' ) {\n\t\t\t\tbeginEmailMatch( State.Mailto );\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\tbeginEmailMatch();\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, continue\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles if we're reading a 'mailto:' prefix on the string\n\t\tfunction stateMailTo( prevChar: MailtoChar, char: string ) {\n\t\t\tif( prevChar === ':' ) {\n\t\t\t\t// We've reached the end of the 'mailto:' prefix\n\t\t\t\tif( localPartCharRegex.test( char ) ) {\n\t\t\t\t\tstate = State.LocalPart;\n\t\t\t\t\tcurrentEmailMatch = new CurrentEmailMatch( { \n\t\t\t\t\t\t...currentEmailMatch, \n\t\t\t\t\t\thasMailtoPrefix: true \n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// we've matched 'mailto:' but didn't get anything meaningful\n\t\t\t\t\t// immediately afterwards (for example, we encountered a \n\t\t\t\t\t// space character, or an '@' character which formed 'mailto:@'\n\t\t\t\t\tresetToNonEmailMatchState();\n\t\t\t\t}\n\n\t\t\t} else if( mailtoTransitions[ prevChar ] === char ) {\n\t\t\t\t// We're currently reading the 'mailto:' prefix, stay in\n\t\t\t\t// Mailto state\n\t\t\t\t\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\t// We we're reading a prefix of 'mailto:', but encountered a\n\t\t\t\t// different character that didn't continue the prefix\n\t\t\t\tstate = State.LocalPart;\n\n\t\t\t} else if( char === '.' ) {\n\t\t\t\t// We we're reading a prefix of 'mailto:', but encountered a\n\t\t\t\t// dot character\n\t\t\t\tstate = State.LocalPartDot;\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\t// We we're reading a prefix of 'mailto:', but encountered a\n\t\t\t\t// an @ character\n\t\t\t\tstate = State.AtSign;\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, return to \"NonEmailAddress\" state\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles the state when we're currently in the \"local part\" of an \n\t\t// email address (as opposed to the \"domain part\")\n\t\tfunction stateLocalPart( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\tstate = State.LocalPartDot;\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\tstate = State.AtSign;\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\t// stay in the \"local part\" of the email address\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, return to \"NonEmailAddress\" state\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles the state where we've read \n\t\tfunction stateLocalPartDot( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\t// We read a second '.' in a row, not a valid email address \n\t\t\t\t// local part\n\t\t\t\tresetToNonEmailMatchState();\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\t// We read the '@' character immediately after a dot ('.'), not \n\t\t\t\t// an email address\n\t\t\t\tresetToNonEmailMatchState();\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\tstate = State.LocalPart;\n\n\t\t\t} else {\n\t\t\t\t// Anything else, not an email address\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction stateAtSign( char: string ) {\n\t\t\tif( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t} else {\n\t\t\t\t// Anything else, not an email address\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainChar( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\tstate = State.DomainDot;\n\n\t\t\t} else if( char === '-' ) {\n\t\t\t\tstate = State.DomainHyphen;\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\t// Stay in the DomainChar state\n\n\t\t\t} else {\n\t\t\t\t// Anything else, we potentially matched if the criteria has\n\t\t\t\t// been met\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainHyphen( char: string ) {\n\t\t\tif( char === '-' || char === '.' ) {\n\t\t\t\t// Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n\t\t\t\tcaptureMatchIfValidAndReset();\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t} else {\n\t\t\t\t// Anything else\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainDot( char: string ) {\n\t\t\tif( char === '.' || char === '-' ) {\n\t\t\t\t// not valid to have two dots (\"..\") or dot+hypen (\".-\")\n\t\t\t\tcaptureMatchIfValidAndReset();\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t\t// After having read a '.' and then a valid domain character,\n\t\t\t\t// we now know that the domain part of the email is valid, and\n\t\t\t\t// we have found at least a partial EmailMatch (however, the\n\t\t\t\t// email address may have additional characters from this point)\n\t\t\t\tcurrentEmailMatch = new CurrentEmailMatch( { \n\t\t\t\t\t...currentEmailMatch, \n\t\t\t\t\thasDomainDot: true \n\t\t\t\t} );\n\n\t\t\t} else {\n\t\t\t\t// Anything else\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction beginEmailMatch( newState = State.LocalPart ) {\n\t\t\tstate = newState;\n\t\t\tcurrentEmailMatch = new CurrentEmailMatch( { idx: charIdx } );\n\t\t}\n\n\t\tfunction resetToNonEmailMatchState() {\n\t\t\tstate = State.NonEmailMatch;\n\t\t\tcurrentEmailMatch = noCurrentEmailMatch;\n\t\t}\n\n\n\n\t\t/*\n\t\t * Captures the current email address as an EmailMatch if it's valid,\n\t\t * and resets the state to read another email address.\n\t\t */\n\t\tfunction captureMatchIfValidAndReset() {\n\t\t\tif( currentEmailMatch.hasDomainDot ) {  // we need at least one dot in the domain to be considered a valid email address\n\t\t\t\tlet matchedText = text.slice( currentEmailMatch.idx, charIdx );\n\n\t\t\t\t// If we read a '.' or '-' char that ended the email address\n\t\t\t\t// (valid domain name characters, but only valid email address\n\t\t\t\t// characters if they are followed by something else), strip \n\t\t\t\t// it off now\n\t\t\t\tif( /[-.]$/.test( matchedText ) ){\n\t\t\t\t\tmatchedText = matchedText.slice( 0, -1 );\n\t\t\t\t}\n\n\t\t\t\tconst emailAddress = currentEmailMatch.hasMailtoPrefix \n\t\t\t\t\t? matchedText.slice( 'mailto:'.length ) \n\t\t\t\t\t: matchedText;\n\n\t\t\t\t// if the email address has a valid TLD, add it to the list of matches\n\t\t\t\tif ( doesEmailHaveValidTld( emailAddress ) ) {\n\t\t\t\t\tmatches.push( new EmailMatch( {\n\t\t\t\t\t\ttagBuilder  : tagBuilder,\n\t\t\t\t\t\tmatchedText : matchedText,\n\t\t\t\t\t\toffset      : currentEmailMatch.idx,\n\t\t\t\t\t\temail       : emailAddress\n\t\t\t\t\t} ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresetToNonEmailMatchState();\n\t\t\n\n\t\t/**\n\t\t * Determines if the given email address has a valid TLD or not\n\t\t * @param {string} emailAddress - email address\n\t\t * @return {Boolean} - true is email have valid TLD, false otherwise\n\t\t */\n\t\tfunction doesEmailHaveValidTld( emailAddress: string ) {\n\t\t\tconst emailAddressTld : string = emailAddress.split( '.' ).pop() || '';\n\t\t\tconst emailAddressNormalized = emailAddressTld.toLowerCase();\n\t\t\tconst isValidTld = strictTldRegex.test( emailAddressNormalized );\n\n\t\t\treturn isValidTld;\n\t\t}}\n\t}\n\n}\n\ntype MailtoChar = 'm' | 'a' | 'i' | 'l' | 't' | 'o' | ':';\n\nconst enum State {\n\tNonEmailMatch = 0,\n\t\n\tMailto,  // if matching a 'mailto:' prefix\n\tLocalPart,\n\tLocalPartDot,\n\tAtSign,\n\tDomainChar,\n\tDomainHyphen,\n\tDomainDot\n}\n\nclass CurrentEmailMatch {\n\treadonly idx: number;  // the index of the first character in the email address\n\treadonly hasMailtoPrefix: boolean;\n\treadonly hasDomainDot: boolean;\n\n\tconstructor( cfg: Partial<CurrentEmailMatch> = {} ) {\n\t\tthis.idx = cfg.idx !== undefined ? cfg.idx : -1;\n\t\tthis.hasMailtoPrefix = !!cfg.hasMailtoPrefix;\n\t\tthis.hasDomainDot = !!cfg.hasDomainDot;\n\t}\n}"]},"metadata":{},"sourceType":"module"}