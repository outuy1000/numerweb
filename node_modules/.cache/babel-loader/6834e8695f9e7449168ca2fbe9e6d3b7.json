{"ast":null,"code":"import { alphaCharsStr } from \"../regex-lib\";\n/**\n * @private\n * @class Autolinker.matcher.UrlMatchValidator\n * @singleton\n *\n * Used by Autolinker to filter out false URL positives from the\n * {@link Autolinker.matcher.Url UrlMatcher}.\n *\n * Due to the limitations of regular expressions (including the missing feature\n * of look-behinds in JS regular expressions), we cannot always determine the\n * validity of a given match. This class applies a bit of additional logic to\n * filter out any false positives that have been matched by the\n * {@link Autolinker.matcher.Url UrlMatcher}.\n */\n\nvar UrlMatchValidator =\n/** @class */\nfunction () {\n  function UrlMatchValidator() {}\n  /**\n   * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}\n   * is valid. Will return `false` for:\n   *\n   * 1) URL matches which do not have at least have one period ('.') in the\n   *    domain name (effectively skipping over matches like \"abc:def\").\n   *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n   * 2) URL matches which do not have at least one word character in the\n   *    domain name (effectively skipping over matches like \"git:1.0\").\n   *    However, URL matches with a protocol will be allowed (ex: 'intra-net://271219.76')\n   * 3) A protocol-relative url match (a URL beginning with '//') whose\n   *    previous character is a word character (effectively skipping over\n   *    strings like \"abc//google.com\")\n   *\n   * Otherwise, returns `true`.\n   *\n   * @param {String} urlMatch The matched URL, if there was one. Will be an\n   *   empty string if the match is not a URL match.\n   * @param {String} protocolUrlMatch The match URL string for a protocol\n   *   match. Ex: 'http://yahoo.com'. This is used to match something like\n   *   'http://localhost', where we won't double check that the domain name\n   *   has at least one '.' in it.\n   * @return {Boolean} `true` if the match given is valid and should be\n   *   processed, or `false` if the match is invalid and/or should just not be\n   *   processed.\n   */\n\n\n  UrlMatchValidator.isValid = function (urlMatch, protocolUrlMatch) {\n    if (protocolUrlMatch && !this.isValidUriScheme(protocolUrlMatch) || this.urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) || // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n    this.urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n    !this.isValidIpAddress(urlMatch) || // Except if it's an IP address\n    this.containsMultipleDots(urlMatch)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  UrlMatchValidator.isValidIpAddress = function (uriSchemeMatch) {\n    var newRegex = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);\n    var uriScheme = uriSchemeMatch.match(newRegex);\n    return uriScheme !== null;\n  };\n\n  UrlMatchValidator.containsMultipleDots = function (urlMatch) {\n    var stringBeforeSlash = urlMatch;\n\n    if (this.hasFullProtocolRegex.test(urlMatch)) {\n      stringBeforeSlash = urlMatch.split('://')[1];\n    }\n\n    return stringBeforeSlash.split('/')[0].indexOf(\"..\") > -1;\n  };\n  /**\n   * Determines if the URI scheme is a valid scheme to be autolinked. Returns\n   * `false` if the scheme is 'javascript:' or 'vbscript:'\n   *\n   * @private\n   * @param {String} uriSchemeMatch The match URL string for a full URI scheme\n   *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.\n   * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n   */\n\n\n  UrlMatchValidator.isValidUriScheme = function (uriSchemeMatch) {\n    var uriSchemeMatchArr = uriSchemeMatch.match(this.uriSchemeRegex),\n        uriScheme = uriSchemeMatchArr && uriSchemeMatchArr[0].toLowerCase();\n    return uriScheme !== 'javascript:' && uriScheme !== 'vbscript:';\n  };\n  /**\n   * Determines if a URL match does not have either:\n   *\n   * a) a full protocol (i.e. 'http://'), or\n   * b) at least one dot ('.') in the domain name (for a non-full-protocol\n   *    match).\n   *\n   * Either situation is considered an invalid URL (ex: 'git:d' does not have\n   * either the '://' part, or at least one dot in the domain name. If the\n   * match was 'git:abc.com', we would consider this valid.)\n   *\n   * @private\n   * @param {String} urlMatch The matched URL, if there was one. Will be an\n   *   empty string if the match is not a URL match.\n   * @param {String} protocolUrlMatch The match URL string for a protocol\n   *   match. Ex: 'http://yahoo.com'. This is used to match something like\n   *   'http://localhost', where we won't double check that the domain name\n   *   has at least one '.' in it.\n   * @return {Boolean} `true` if the URL match does not have a full protocol,\n   *   or at least one dot ('.') in a non-full-protocol match.\n   */\n\n\n  UrlMatchValidator.urlMatchDoesNotHaveProtocolOrDot = function (urlMatch, protocolUrlMatch) {\n    return !!urlMatch && (!protocolUrlMatch || !this.hasFullProtocolRegex.test(protocolUrlMatch)) && urlMatch.indexOf('.') === -1;\n  };\n  /**\n   * Determines if a URL match does not have either:\n   *\n   * a) a full protocol (i.e. 'http://'), or\n   * b) at least one word character after the protocol (i.e. in the domain name)\n   *\n   * At least one letter character must exist in the domain name after a\n   * protocol match. Ex: skip over something like \"git:1.0\"\n   *\n   * @private\n   * @param {String} urlMatch The matched URL, if there was one. Will be an\n   *   empty string if the match is not a URL match.\n   * @param {String} protocolUrlMatch The match URL string for a protocol\n   *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we\n   *   have a protocol in the URL string, in order to check for a word\n   *   character after the protocol separator (':').\n   * @return {Boolean} `true` if the URL match does not have a full protocol, or\n   * at least one word character in it, `false` otherwise.\n   */\n\n\n  UrlMatchValidator.urlMatchDoesNotHaveAtLeastOneWordChar = function (urlMatch, protocolUrlMatch) {\n    if (urlMatch && protocolUrlMatch) {\n      return !this.hasFullProtocolRegex.test(protocolUrlMatch) && !this.hasWordCharAfterProtocolRegex.test(urlMatch);\n    } else {\n      return false;\n    }\n  };\n  /**\n   * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n   *\n   * @private\n   * @property {RegExp} hasFullProtocolRegex\n   */\n\n\n  UrlMatchValidator.hasFullProtocolRegex = /^[A-Za-z][-.+A-Za-z0-9]*:\\/\\//;\n  /**\n   * Regex to find the URI scheme, such as 'mailto:'.\n   *\n   * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n   *\n   * @private\n   * @property {RegExp} uriSchemeRegex\n   */\n\n  UrlMatchValidator.uriSchemeRegex = /^[A-Za-z][-.+A-Za-z0-9]*:/;\n  /**\n   * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n   *\n   * @private\n   * @property {RegExp} hasWordCharAfterProtocolRegex\n   */\n\n  UrlMatchValidator.hasWordCharAfterProtocolRegex = new RegExp(\":[^\\\\s]*?[\" + alphaCharsStr + \"]\");\n  /**\n   * Regex to determine if the string is a valid IP address\n   *\n   * @private\n   * @property {RegExp} ipRegex\n   */\n\n  UrlMatchValidator.ipRegex = /[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?(:[0-9]*)?\\/?$/;\n  return UrlMatchValidator;\n}();\n\nexport { UrlMatchValidator };","map":null,"metadata":{},"sourceType":"module"}